#include <vector>
#include <cmath>
#include "trajectorygenerator.hpp"

/**
 * @brief Generates a linearly spaced vector of doubles from start to end with num elements.
 * Each element is spaced evenly between start and end.
 * If num is 0, returns an empty vector.
 * 
 * @param start The starting value of the sequence.
 * @param end The ending value of the sequence.
 * @param num The number of elements in the sequence.
 * @return A vector of doubles containing the linearly spaced values.
 */
std::vector<double> TrajectoryGenerator::linspace(float start, float end, int num) {
    std::vector<double> result;

    if (num == 0) {
        return result;
    }

    double step = (end - start) / (num);

    for (int i = 0; i < num; i++) {
        result.push_back(start + i * step);
    }

    return result;
}

/**
 * @brief Generates a Hermite spline between two poses.
 * The spline is generated using the start and end poses, and the tangents are
 * calculated based on the orientation of the poses.
 * The function returns a vector of poses representing the spline.
 * 
 * A Hermite spline is a type of spline that is defined by a start point, an end point, and 
 *  the tangents (or derivatives) at those points. This allows for control of the robot's angle at
 *  the start and end of the spline.
 * 
 * The spline is defined by the following equation:
 * 
 *  P(t) = h00​(t) * P0​ + h10​(t) * M0 ​+ h01​(t) * P1 ​+ h11​(t) * M1​
 * 
 * where:
 * 
 *  h00(t) = 2t^3 - 3t^2 + 1
 * 
 *  h10(t) = t^3 - 2t^2 + t
 * 
 *  h01(t) = -2t^3 + 3t^2
 * 
 *  h11(t) = t^3 - t^2
 * 
 * P0 and P1 are the start and end poses, respectively.
 * M0 and M1 are the tangents at the start and end poses, respectively.
 * t is a parameter that varies from 0 to 1.
 * 
 * For more information on Hermite splines, see: https://en.wikipedia.org/wiki/Cubic_Hermite_spline
 * 
 * @param startPose The starting pose of the spline.
 * @param endPose The ending pose of the spline.
 * @param numPoints The number of points to generate along the spline. Default is 100.
 * 
 * @return A vector of poses representing the Hermite spline. Note that the heading of each pose is undefined.
 */
std::vector<Pose> TrajectoryGenerator::generateHermiteSpline(Pose startPose, Pose endPose, int numPoints) {
    std::vector<double> tVals = TrajectoryGenerator::linspace(0, 1, numPoints);

    std::vector<Pose> result;

    // Scale factor for the tangents. Adjust this value to change the "tightness" of the curve.
    double tangentScale = startPose.distanceTo(endPose) / 2.5; 

    double M0[2] = {tangentScale* (std::cos((-1 * startPose.getTheta()) + M_PI_2)),
                    tangentScale * (std::sin((-1 * startPose.getTheta()) + M_PI_2))};

    double M1[2] = {tangentScale * (std::cos((-1 * endPose.getTheta()) + M_PI_2)),
                    tangentScale * (std::sin((-1 * endPose.getTheta()) + M_PI_2))};

    double h00, h10, h01, h11, x, y;

    for (double t : tVals) {
        h00 =  2*pow(t,3) - 3*pow(t,2) + 1;
        h10 =  pow(t,3) - 2*pow(t,2) + t;
        h01 = -2*pow(t,3) + 3*pow(t,2);
        h11 =  pow(t,3) - pow(t,2);

        x = h00*startPose.getX() + h10*M0[0] + h01*endPose.getX() + h11*M1[0];
        y = h00*startPose.getY() + h10*M0[1] + h01*endPose.getY() + h11*M1[1];

        result.push_back(Pose(x, y, 0));
    }

    return result;
}

/**
 * @brief Generates a trajectory through a series of waypoints using Hermite splines.
 * The function takes an array of waypoints and generates a smooth trajectory that passes through each waypoint.
 * The trajectory is generated by creating Hermite splines between each pair of consecutive waypoints.
 * 
 * @param waypoints An array of Pose objects representing the waypoints. The array should contain at least two waypoints.
 * @return A vector of Pose objects representing the generated trajectory.
 */
Trajectory TrajectoryGenerator::generateTrajectory(std::vector<Pose> waypoints) {
    std::vector<Pose> result = TrajectoryGenerator::generateHermiteSpline(waypoints[0], waypoints[1], 20);
    std::vector<Pose> temp;
    
    for (int i = 1; i < waypoints.size() - 1; i++) {
        temp = TrajectoryGenerator::generateHermiteSpline(waypoints[i], waypoints[i + 1], 20);
        
        result.insert(result.end(), temp.begin(), temp.end());
    }    
    
    Trajectory trajectory(waypoints, result);

    return trajectory;
}